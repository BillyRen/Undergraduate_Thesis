\chapter{绪论}
\section{引言}
自动化数据采集技术是信息采集和处理的关键技术。随着工业自动化和数字化的发展，自动识别技术有了更加广泛的应用，极大地提高了各行业的生产效率。条码识别技术是计算机图像处理、模式识别、光电信息技术和通信技术为基础的综合技术，已经成为现在数据自动输入、识别的重要方法和途径。

条码可以分为一维条码（One Dimensional Code）和二维条码（Two Dimensional Code）两类。一维条码容量有限，仅能标识商品，不能存储更多信息，必须依赖数据库。二维条码相比之下，容量大大提升。同时，由于加入的纠错编码，鲁棒性更强，可靠防伪。二维条码可以用来表示多种语言、图像数据，不仅可以将字符信息、数字编译存储，而且可以将个人的生物信息：如人脸数据、指纹和虹膜等图像信息存入条码。

一维条码只有校验功能，即检验识别的信息是否正确。二维条码由于引入了纠错条码，具有很强的错误校验和纠正功能。在条码部分损毁、有污点的情况下，也可以被正确恢复和识别。

二维条码按照不同的规定，按照一定规律在平面上分布黑白相间的图形用以记录数据信息。按照模块的深浅堆积方式不同，分为矩阵式和堆叠式两种。矩阵式条码将不同深浅的模块排列在图像中；堆叠式二维码采取行排列，将一维条码堆叠在一起。

在现阶段，应用较为广泛的二维条码主要有两类：QR码和Data Matrix码。在工业上应用较多的是后者。

\section{二维条码技术简介}
从20世纪后期开始，二维条码由于其独特的优势，开始受到许多国家的关注。现在，已经有专门的机构负责制定条码标准。我国目前也在现在已经制定完成的二维码标准之上进行了改进，以适应不断更新的需求。

最早的堆叠式二维码――PDF147――由美国发明。之后，各种二维码相继面世：专门为邮政系统设计的CodeOne和QR码等。现在，二维码不光用在证件信息管理中，在商业、餐饮、交通运输等部门的物流和工业生产线上的自动化管理部分也有着十分重要的应用。现在，还有金属条码、纤维织物条码以及三维条码等多种新型码都在研发之中，进一步扩大了条码的应用范围和前景。

我国对于二维码的研究开始于1993年，相对落后与发达国家。目前，国内二维码的标准还不够完善，也没有独立的解码技术。随着信息时代数据量的增加以及市场的驱动，国内对二维码技术的需求与日俱增，相关研究也日益增多。现在，我国的身份证件系统、互联网身份识别等领域已经开始对二维码有大规模的使用。

\section{Data Matrix条码简介}
\subsection{Data Matrix条码结构}
Data Matrix原名Datacode，由美国国际资料公司(International Data Matrix, 简称ID Matrix)于1989年发明。
%这里插入DMC图片

Data Matrix是一种矩阵式二维条码，其发展的构想是希望在较小的条码标签上存入更多的资料量。Data Matrix的最小尺寸是目前所有条码中最小的，尤其特别适用于小零件的标识，以及直接印刷在实体上。

Data Matrix码（以下称做DM码）的符号结构由寻边区和数据区组成。寻边区包括两部分：L字型实心边界和铁道线。寻边区是DM码的边界。L字型边界用来限制条码的物理边界，确定DM码的位置和角度。铁道线用来确定模块的单元结构，同时可以辅助确定条码的物理尺寸以及形变。条码中间的编码区包含着编码信息，按照一定的编码规则，可以包括数字、字母和汉字等信息。

DM码由黑白两种颜色的模块构成，每一个模块被称作一个数据单位，分别代表着0和1。

DM码有ECC000-140和ECC200两种类型，ECC000-140具有多种不同等级的纠错功能，ECC200通过Reed-Solomo纠错码产生多项式计算出纠错码。根据尺寸的不同，包含的容量两也不同。ECC200由于其算法容易，并且尺寸有弹性，应用较为普遍。

\subsection{Data Matrix编码规则}
Data Matrix 符号的数据区由规则排列的方形深浅模块构成。数据区的四周是探测
图形(Finder Pattern)，探测图形外则是空白区，如图（）所示。探测图形为一个模
块宽度，是数据区的边界，其中两条邻边为暗实线，形成了一个L 型边界，用于限
定物理尺寸、定位和符号失真。另两条邻边由交替的深色模块和浅色模块组成，主
要用于限定符号的单元结构，也能帮助确定物理尺寸及失真。
%这里要插入一个表格
%介绍Data Matrix 编码规则

\section{二维条码研究现状}
Data Matrix码是使用最为广泛的二维条码之一。由于其最小尺寸是目前所有二维码中最小的，特别适合于小零件的标记以及直接印刷。因此现在Data Matrix在工业领域有着大量应用，主要集中于集成电路和药品的小物件以及制造业流水线的生产过程中。

之前SARJAKOSKI等人提出了将Data Matrix用于处理地图数据，他们使用的DataMatrix算法主要是先进行图像滤波处理，再用Hough变换进行直线检测。基于这一思路，后续一部分工作在于对直线检测步骤的优化。

胡晓岽等人基于Java开发了一套DM码识别方案，为以后将该系统移植到手机平台打下了基础。他们的算法主要包括：预处理、初定位和精确定位。采用Hough变换求取条码的旋转角度; 他们的流程如下图所示：

%这里应当插入流程图1

邹沿新等人没有使用传统的边缘检测和直线检测手段。采用十字搜索法来得到“L”形边界。此类算法受背景噪声、几何失真的影响较小，但时间复杂度较高。适用于小图像以及实时性需求不高的场所。但是在工业流水线上，此类算法不能满足速度要求。他们的算法识别包含单个条码的320*240的图像时间为5ms。

姚林昌等人同样没有采用Hough变换。他们的算法首先进行矩形检测，大致确定Data Matrix条码位置，然后用距离为角度的函数将Data Matrix条码2D边界分析变成1D 波函数分析。他们的算法平均识别时间为12.06ms，识别率为99.22\%，达到了工业现场实时性和可靠性的要求。

天津大学的刘峰（音译）等人提出了一个Data Matrix的鲁棒性很好的快速定位算法。该算法采取两步定位，第一步通过Sobel滤波进行边缘检测，先大致确定条码所在区域，第二步对ROI进行扫描确定条码的精确边界。在精确定位过程中，他们采取了直接扫描的方式，对条码边界进行追迹。该方法速度较快，但是对于图像噪声水平有比较高的要求。

黄强等人也采用了两步定位算法。他们首先采用L字型追迹方法确定条码的位置和角度，然后利用形态学处理确定条码的边界。他们的算法在复杂背景环境下定位精确度非常高，但是算法较为复杂，不能满足工业实时性要求。

除了传统的印刷Data Matrix，在流水线上主要使用的还有点状雕刻的Data Matrix （Dotted Data Matrix）。对于点状雕刻码，国内尚没有过多的研究。只有陈袁飞（音译）提出过一个扫描算法。他首先确定ROI，采用的是从图像中心向外扫描的方法。然后通过最远点确定条码边界。最后用了投影法对铁道线进行扫描，从而确定了条码模块的大小。该算法主要解决了工业照相机拍摄有角度的问题。

国外的Dita对这一问题有比较多的研究。除了提出一个通用的算法，他还专门针对倾斜和变形的情况进行了研究。他首先用形态学生长算法处理图像，从而使条码成为一个完整的矩形。然后通过对边界的追迹确定条码的倾斜角度，进而确定条码的顶点。对于由于工业照相机角度问题而造成条码倾斜的情况，他创造了一个映射点矩阵对条码进行覆盖，直接读取条码0/1信息。对于打印到曲面的条码，他利用曲面的角度和条码的大小等信息，可以构造一个映射矩阵，对条码进行覆盖读取。同时，他还提出了一种用Meanshift聚类算法对条码位置进行定位的方法。

Data Matrix码的传统定位方法需要通过L字型和铁道线对边界进行确定。常用的线检测算法往往耗时较长，并且在复杂背景下效果不好。

工业照相机由于环境限制，往往不能很好的对条码进行采集，经常会出现光照度不均匀、模糊、条码位置偏移等情况。这往往会给条码定位带来困难。

现在Data Matrix定位算法的一个限制在于时间。二维码识别速度是流水线效率的瓶颈。现在的算法定位300K图像中的一个Data Matrix 时间最快在5ms左右，解码时间在5ms左右。工业上对定位速度有更高的要求，以适应生产需求。

现在Data Matrix定位算法的另一个限制在于复杂环境下的识别。工业上采集系统的环境比较复杂，特别是点状雕刻的条码，很难从背景中分离出来。因此对定位算法提出了很高的鲁棒性要求。

%这里插入工业上的二维码图片

\section{二维条码识别技术}
\subsection{图像预处理}
主要是指对图像进行裁剪、降噪以及二值化操作，从而减少复杂背景以及光照度不均匀对后期识别的影响。常用的降噪方法有邻域均值降噪、中值滤波和低通滤波等。在OpenCV实现中，还可以利用图像金字塔%这里插入关于图像金字塔的引用）
对图像进行降噪处理。二值化的方法主要是Otsu法（大律法）。下文%确定是第几章
会详细介绍相关图像处理算法。

\subsection{条码初定位}
主要是在采集到的图像中初步确定二维条码所在的区域，并且将该区域从图像中分割开来，进行下一步处理。常用的初定位方法有连通域标记和形态学处理等。下文%确定是第几章
将会对相关算法进行详细介绍。

\subsection{条码精确定位}
利用不同条码各自的定位特征，对条码边界进行精确定位。在下文中对Data Matrix精确定位算法进行了更加深入的讨论

\subsection{条码图像纠偏}
在工业上，一般来说精确定位后的条码往往会存在一定程度的偏转、变形等问题，需要通过一定的变换将条码调整到合适的位置和方向，方便下一步识别。常用的校正方法有仿射变换等。

\subsection{RS纠错}
Data Matrix采取了Reed-Solomon算法来进行校验和纠错，在很大程度上可以恢复由于损毁、污渍等状况造成的条码信息损失。由于本文主要是研究定位算法，因此对RS纠错算法没有过多的讨论。

\subsection{0/1识别和解码}
通过网格化，对条码信息进行读取，并且根据相应的编码规则，识别出条码中所包含的信息。

%下面的内容先注释掉，有时间再学习。
\iffalse
\TeX在不同的操作系统上有不同的实现版本。Windows系统上是MiKTEX。CTeX中文套装集成了MiKTEX和一些常用的相关工具，如GSView，并添加了对中文的支持。

CTeX软件可以在98软件站上下载。安装好后，生成桌面图标WinEdt。打开文件Example.tex，使用TeX 下拉菜单中的LaTeX,PDF-dvi2pdf进行编译（图\ref{fig:CTEX}），
就可以预览排版后的文章了。

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=0.8\linewidth]{CTEX.jpg}
\end{center}
\caption{CTEX软件界面}
\label{fig:CTEX}
\end{figure}
\fi

\chapter{二维条码中的图像处理方法和定位技术}
\section{Ostu法（大津法）}
最大类间方差法是由日本学者大津展之于1979 年提出的，是一种自适应的阈值确定的方法,又叫大津法，简称OTSU。它是按图像的灰度特性,将图像分成背景和目标两部分。背景和目标之间的类间方差越大，说明构成图像的两部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致两部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。

对于图像I(x,y)，前景(即目标)和背景的分割阈值记作T，属于前景的像素点数占整幅图像的比例记为w0，其平均灰度u0；背景像素点数占整幅图像的比例为w1，其平均灰度为u1。图像的总平均灰度记为u，类间方差记为g。假设图像的背景较暗,并且图像的大小为M*N，图像中像素的灰度值小于阈值T的像素个数记作N0，像素灰度大于阈值T的像素个数记作N1,则有:

\begin{equation}
\mathop \omega \nolimits_0  = \frac{{\mathop N\nolimits_0 }}{{M*N}}
\end{equation}
\begin{equation}
\mathop \omega \nolimits_1  = \frac{{\mathop N\nolimits_1 }}{{M*N}}
\end{equation}
\begin{equation}
{N_0} + {N_1} = M*N
\end{equation}
\begin{equation}
{\omega _0} + {\omega _1} = 1
\end{equation}
\begin{equation}
\mu  = {\omega _0}*{\mu _0} + {\omega _1}*{\mu _1}
\end{equation}
\begin{equation}
g = {\omega _0}{({\mu _0} - \mu )^2} + {\omega _1}{({\mu _1} - \mu )^2}
\end{equation}

将公式整理，可以得到：
\begin{equation}
g = {\omega _0}{\omega _1}{({\mu _0} - {\mu _1})^2}
\end{equation}
采用遍历的方法得到使类间方差最大的阈值，即为所求。

\section{边缘检测方法}
边缘检测技术对于图像处理十分重要。通常边缘提取是将ROI（Region of Interest）与背景分离出来的前提条件。现在的边缘检测算法根据原理，可以分成三大类：一类是基于固定的局部算法，如微分算子法等。这类算法属于经典的边缘提取方法。第二类一般是以能量最小化为目标的全局提取方法。该类算法从全局最优的角度提取边缘，如神经网络分析法等。第三类则是最近发展起来的，以小波变换、形态学和分型理论等技术为代表。在二维码识别中，考虑到速度和实际需要，一般采取的是经典边缘提取方法。该类方法特点是处理迅速，虽然效果稍差，但已经能够满足工业上实际需要。

\subsection{微分算子法}
该类方法通过空域微分算子卷积来进行边缘提取。微分算子可以突出灰度变化。通过对导数值设置一定的门限，可以提取边界点集。

梯度模是一个连续函数f(x,y)在（x,y）处方向导数的最大值。通过梯度模可以有效地进行边缘检测，它不仅仅具有导数不变性，还有各项同性。常用的Roberts算子和Sobel算子的表达式分别为：
%Roberts和Sobel的公式

\subsection{拉普拉斯高斯算子法}
拉普拉斯高斯（LOG）算法是一种二阶微分边缘检测方法%（引用：方法及展望）。
通过寻找图像中灰度值二阶导数零点来检测边缘点。在实际应用中，一般会用高斯函数对图像进行滤波来降噪。

\subsection{Canny算子法}
边缘提取的重点在于增强边缘的同时不能引入更多的噪声。由于图像边缘和噪声在频域中都属于高频分量，因此简单的微分运算在增强边缘的同时往往也会引入更多噪声。一般在微分运算之前都会采取适当的平滑滤波。Canny% （引用：Canny当年论文）
对此问题进行了分析，并且从数学上推导出了4个指数函数线性组合形式的最佳边缘提取算子网。Canny算子利用高斯算子的一阶微分，在增强边缘和抑制噪声之前找到了比较好的平衡。

\subsection{边缘提取效果对比}
%图：对比图
从图中可以看出，Roberts算子提取边缘的结果边缘较粗，不是十分精确。采用Sobel和Prewitt算子的结果对边缘的定位要好于Roberts算子。采用拉普拉斯高斯算子的结果明显优于前面三种算子，边缘较为完整，位置比较准确。Canny算子提取的边缘最为完整，连续性非常好。这主要是因为Canny算子采取了“非极大值抑制”和形态学操作。

\section{形态学运算}
形态学（morphology）一词通常代表生物学的一个分立。它是研究动物和植物的形态和结构的学科。数学形态学（mathematical morphology）作为工具可以从图像中提取出对于表达和描绘区域形状有用处的图像分量，如边界、骨架和凸壳等。形态学的常用操作包括膨胀、腐蚀、开/闭运算、击中与不击中运算等。

\subsection{膨胀与腐蚀}
A和B是$Z^2$的集合，A被B膨胀可以表示为$A \oplus B$，定义为：
\begin{equation}
A \oplus B = \{ z|{(\hat B)_z} \cap A \ne \emptyset \}
\end{equation}
B集合通常叫做膨胀的结构元素。

下图是一个形态学膨胀过程：
%图：膨胀过程

A和B是$Z^2$的集合，A被B腐蚀可以表示为$A \cdot B$，定义为：
\begin{equation}
A \ominus B = \{ z|{(B)_z} \subseteq A\}
\end{equation}
同样的，B集合通常叫做腐蚀的结构元素。

下图是一个形态学腐蚀过程：
%图：腐蚀过程

\subsection{开运算与闭运算}
膨胀使图像扩大，而腐蚀使图像缩小。在形态学中，另外还有另外两类重要的形态学操作：开操作与比操作。开操作一般使得对象的轮廓变得光滑，断开狭窄的间断和消除细的突出物；闭操作同样使得对象的轮廓变得更光滑，但与开操作相反，它通常消弭狭窄的间断和长细的鸿沟，消除小的空洞，并填补轮廓线中的断裂。

用结构元素B对A进行开操作，表示为$A \circ B$, 定义为：
\begin{equation}
A \circ B = (A \ominus B) \oplus B
\end{equation}
因此，用B对A进行开操作就是用B对A进行腐蚀，然后用B对结果进行腐蚀。

同样，使用结构元素B对集合A进行的闭操作，表示为$A \bullet B$，定义如下：
\begin{equation}
A \bullet B = (A \oplus B) \ominus B
\end{equation}
这个公式说明，使用结构元素B对集合A的闭操操就是用B对A进行膨胀，而后用B对结果进行腐蚀。

开操作有一个简单的解释。假设我们将结构元B看做一个 （扁平的）“转球”。$A \circ B$的边界通过B中的点完成，即B在A的边界内转动时，B中的点所能到达的A的边界的最远点。这个开操作的几何拟合特性使我们得出了集合论的一个公式。这个公式说明用B对A进行开操作是通过求取B在拟合A时的平移的并集得到的。就是说，开操作可以表示为一个拟合操作：
\begin{equation}
A \circ B = \cup \{(B)_z|(B)_z \subseteq A\ \}
\end{equation}
闭操作有着相似的几何解释。只是我们现在在边界的外部转动B。简而言之，开操作和闭操作是一对对偶操作，所以闭操作在边界外部转动球是预料之中的事情。


\chapter{OpenCV机器视觉库介绍}
\section{OpenCV简介}
OpenCV是一个开源（开源定义）的计算机视觉库，项目主页为：（项目主页）。OpenCV采用C/C++语言编写，可以运行在Linux、Windows 和Mac等操作系统上。OpenCV 还提供了Python、Ruby、MATLAB以及其他语言的接口。

OpenCV的设计目标是执行速度尽量快，主要关注实时应用。它采用优化的C代码，能够充分利用多核处理器的优势。

OpenCV的一个目标是构建一个简单易用的计算机视觉框架，以帮助开发人员更加便捷的设计复杂的计算机视觉应用程序。OpdnCV中包含500多个函数，覆盖了计算机视觉的许多应用领域，例如：工厂产品检测、医学成像、信息安全、用户界面、摄像机标定、立体视觉和机器人等。因为计算机视觉和机器学习密切相关，所以OpenCV还提供了Machine Learning Library。该库侧重于统计方面的模式识别和聚类。MLL除了用在计算机视觉相关人物中，也可以方便的应用于其他机器学习场合。

\section{OpenCV发展历史}
OpenCV诞生于Intel研究中心，其目的是为了促进CPU密集型应用。为了达到这个目的，Intel启动了多个项目，其中包括实时光线追踪和三维显示墙。一位在Intel工作的OpenCV 作者在访问一些大学的时候，发现许多顶尖大学的实验室（如MIT的多媒体实验室）拥有很好的内部使用的开发计算机视觉库――在学生间相互传播的代码，这会帮助一个新生从高的起点开始计算机视觉研究。

因此，OpenCV的目的是开发一个普遍可用的计算机视觉库。在Intel 的性能库团队的帮助下，OpenCV实现了一些核心的代码以及算法，并且发给Intel俄罗斯的库团队。这就是OpenCV的诞生之地：在与软件性能库团队的合作下，它开始于Intel的研究中心，并且在俄罗斯得到实现和优化。

\section{OpenCV基本结构}
OpenCV主要结构可分成五部分，其中四个模块如图（\ref{fig:opencv_structure}）所示。OpenCV的CV模块包含基本的图像处理函数和高级的计算机视觉算法。MLL是机器学习库，包含一些基于统计的分类和聚类工具。HighGUI包含图像和视频的I/O函数。CXCore 包含OpenCV的一些基本数据结构和相关函数。
\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=0.8\linewidth]{opencv_structure.png}
\end{center}
\caption{OpenCV基本结构}
\label{fig:opencv_structure}
\end{figure}

该图中没有包含CvAux模块。该模块中一般存放一些即将被淘汰的算法和函数（如基于嵌入式隐含马尔科夫模型的人脸识别算法），同时还有一些新出现的实验性的算法和函数（如背景和前景的分割）。

\section{OpenCV数据结构}
在OpenCV中，图像主要是以cv::Mat类的进行存储和处理的。

Opencv2.0版本发布后，其新的C++接口，cv::Mat代替了原来c风格的CvMat和IplImage.目前，2.0版本对c的接口也是支持的。

相对于c的接口，c++的cv::Mat统一了矩阵和图像这两个概念。事实上，矩阵和图像其实是一样的。由于cv::Mat是c++的类，所以也具备了相关的一些特征。例如，内存的释放。在C++中，一个对象超出其使用范围后，会自动调用析构函数进行销毁。而在c中，如果给CvMat类型的变量使用函数cvCreateImage 等函数分配了内存空间，那么必须调用相应的函数进行释放，而不会自动销毁。如果没有相应的释放，则会造成内存泄漏。

\section{OpenCV基本操作}
\subsection{矩阵操作}
在使用c++接口前，先包含相应的OpenCV namespace。

在使用\#include语句包含相应头文件后，使用下面语句即可包含相应的opencv命名空间:

\begin{lstlisting}[frame=shadowbox]
using namespace cv;
\end{lstlisting}

如果没有这个语句，那么在这个命名空间的相关资源就需要带上cv前缀，如cv:Mat， 表示的是使用命名空间cv中的Mat； 而有了using namespace cv这个语句后，就可以直接写Mat。

这个新的类型Mat支持类似于matlab风格的矩阵代数运算，例如：

\begin{lstlisting}[frame=shadowbox]
Mat A = Mat(3,4,CV_32FC1);
Mat B = Mat(4,3,CV_32FC1);
Mat C = 2*A*B;
\end{lstlisting}

那么，矩阵C是一个3*3矩阵，是矩阵A和矩阵B 做矩阵乘法后，乘上因子2的结果。这种方式比c接口好像要更直观一点。

Mat还有其他对矩阵操作的方法，例如：

\begin{lstlisting}[frame=shadowbox]
Mat C = C.inv(); //Now C is its own inverse matrix
Mat D = A.t(); //D is the transposed matrix of A **
\end{lstlisting}

\subsection{基本图像操作}
\subsubsection{图像读取}
在OpenCV中，读取的图像都存放在cv::Mat类的一个对象中：

\iffalse
\begin{lstlisting}[frame=shadowbox]
cv::Mat image;
image = cv::imread("img.jpg");
if (!image.data){
}
cv::namedWindow("Original Image");//Define the window
cv::imshow("Original Image", image);//show the image
\end{lstlisting}
\fi

\subsubsection{图像翻转}
利用OpenCV中的cv::flip函数，调节相关参数，我们可以很方便的实现图像各方向翻转功能。

\begin{lstlisting}[frame=shadowbox]
cv::Mat result;
cv::flip(image, result, 1);
cv::namedWindow("Output Image");
cv::imshow("Output Image", result);
cv::waitKey(0);
cv::imwrite("output.bmp", result);
\end{lstlisting}

